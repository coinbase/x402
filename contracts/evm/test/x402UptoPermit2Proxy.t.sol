// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test} from "forge-std/Test.sol";
import {VmSafe} from "forge-std/Vm.sol";
import {x402UptoPermit2Proxy} from "../src/x402UptoPermit2Proxy.sol";
import {x402BasePermit2Proxy} from "../src/x402BasePermit2Proxy.sol";
import {ISignatureTransfer} from "../src/interfaces/ISignatureTransfer.sol";
import {MockPermit2} from "./mocks/MockPermit2.sol";
import {MockERC20} from "./mocks/MockERC20.sol";
import {MockERC20Permit} from "./mocks/MockERC20Permit.sol";
import {MaliciousReentrantUpto} from "./mocks/MaliciousReentrantUpto.sol";

contract X402UptoPermit2ProxyTest is Test {
    x402UptoPermit2Proxy public proxy;
    MockPermit2 public mockPermit2;
    MockERC20 public token;

    address public payer;
    address public recipient;

    uint256 constant MINT_AMOUNT = 10_000e6;
    uint256 constant TRANSFER_AMOUNT = 100e6;

    event Settled();
    event SettledWithPermit();
    event EIP2612PermitFailed(address indexed token, address indexed owner, bytes reason);

    function setUp() public {
        vm.warp(1_000_000);

        payer = makeAddr("payer");
        recipient = makeAddr("recipient");

        mockPermit2 = new MockPermit2();
        // Use broadcast to ensure tx.origin matches msg.sender for initialize()
        vm.startBroadcast();
        proxy = new x402UptoPermit2Proxy();
        proxy.initialize(address(mockPermit2));
        vm.stopBroadcast();
        token = new MockERC20("USDC", "USDC", 6);

        token.mint(payer, MINT_AMOUNT);
        vm.prank(payer);
        token.approve(address(mockPermit2), type(uint256).max);
        mockPermit2.setShouldActuallyTransfer(true);
    }

    function _permit(
        uint256 amount,
        uint256 nonce,
        uint256 deadline
    ) internal view returns (ISignatureTransfer.PermitTransferFrom memory) {
        return ISignatureTransfer.PermitTransferFrom({
            permitted: ISignatureTransfer.TokenPermissions({token: address(token), amount: amount}),
            nonce: nonce,
            deadline: deadline
        });
    }

    function _witness(address to, uint256 validAfter) internal pure returns (x402BasePermit2Proxy.Witness memory) {
        return x402BasePermit2Proxy.Witness({to: to, validAfter: validAfter});
    }

    function _sig() internal pure returns (bytes memory) {
        return abi.encodePacked(bytes32(uint256(1)), bytes32(uint256(2)), uint8(27));
    }

    // --- Initialize ---

    function test_initialize_revertsOnZeroPermit2() public {
        vm.startBroadcast();
        x402UptoPermit2Proxy newProxy = new x402UptoPermit2Proxy();
        vm.expectRevert(x402BasePermit2Proxy.InvalidPermit2Address.selector);
        newProxy.initialize(address(0));
        vm.stopBroadcast();
    }

    function test_initialize_setsPermit2() public view {
        assertEq(address(proxy.PERMIT2()), address(mockPermit2));
    }

    function test_initialize_revertsOnSecondCall() public {
        vm.startBroadcast();
        x402UptoPermit2Proxy newProxy = new x402UptoPermit2Proxy();
        newProxy.initialize(address(mockPermit2));
        vm.expectRevert(x402BasePermit2Proxy.AlreadyInitialized.selector);
        newProxy.initialize(address(mockPermit2));
        vm.stopBroadcast();
    }

    function test_initialize_revertsOnUnauthorizedCaller() public {
        vm.startBroadcast();
        x402UptoPermit2Proxy newProxy = new x402UptoPermit2Proxy();
        vm.stopBroadcast();
        // Now try to initialize from a different address (attacker)
        address attacker = makeAddr("attacker");
        vm.prank(attacker);
        vm.expectRevert(x402BasePermit2Proxy.UnauthorizedInitializer.selector);
        newProxy.initialize(address(mockPermit2));
    }

    // --- settle() validation ---

    function test_settle_revertsOnZeroOwner() public {
        uint256 t = block.timestamp;
        vm.expectRevert(x402BasePermit2Proxy.InvalidOwner.selector);
        proxy.settle(
            _permit(TRANSFER_AMOUNT, 0, t + 3600), TRANSFER_AMOUNT, address(0), _witness(recipient, t - 60), _sig()
        );
    }

    function test_settle_revertsOnZeroDestination() public {
        uint256 t = block.timestamp;
        vm.expectRevert(x402BasePermit2Proxy.InvalidDestination.selector);
        proxy.settle(
            _permit(TRANSFER_AMOUNT, 0, t + 3600), TRANSFER_AMOUNT, payer, _witness(address(0), t - 60), _sig()
        );
    }

    function test_settle_revertsBeforeValidAfter() public {
        uint256 t = block.timestamp;
        vm.expectRevert(x402BasePermit2Proxy.PaymentTooEarly.selector);
        proxy.settle(_permit(TRANSFER_AMOUNT, 0, t + 3600), TRANSFER_AMOUNT, payer, _witness(recipient, t + 60), _sig());
    }

    // Note: validBefore was removed - upper time bound is enforced by Permit2's deadline

    function test_settle_revertsOnZeroAmount() public {
        uint256 t = block.timestamp;
        vm.expectRevert(x402BasePermit2Proxy.InvalidAmount.selector);
        proxy.settle(_permit(TRANSFER_AMOUNT, 0, t + 3600), 0, payer, _witness(recipient, t - 60), _sig());
    }

    function test_settle_revertsOnZeroPermittedAmount() public {
        uint256 t = block.timestamp;
        vm.expectRevert(x402BasePermit2Proxy.InvalidAmount.selector);
        proxy.settle(_permit(0, 0, t + 3600), 0, payer, _witness(recipient, t - 60), _sig());
    }

    function test_settle_revertsWhenAmountExceedsPermitted() public {
        uint256 t = block.timestamp;
        vm.expectRevert(x402UptoPermit2Proxy.AmountExceedsPermitted.selector);
        proxy.settle(_permit(100e6, 0, t + 3600), 150e6, payer, _witness(recipient, t - 60), _sig());
    }

    // --- settle() success paths ---

    function test_settle_transfersTokens() public {
        uint256 t = block.timestamp;
        uint256 balanceBefore = token.balanceOf(recipient);

        proxy.settle(_permit(TRANSFER_AMOUNT, 0, t + 3600), TRANSFER_AMOUNT, payer, _witness(recipient, t - 60), _sig());

        assertEq(token.balanceOf(recipient) - balanceBefore, TRANSFER_AMOUNT);
    }

    function test_settle_emitsSettled() public {
        uint256 t = block.timestamp;

        vm.expectEmit(false, false, false, false);
        emit Settled();

        proxy.settle(_permit(TRANSFER_AMOUNT, 0, t + 3600), TRANSFER_AMOUNT, payer, _witness(recipient, t - 60), _sig());
    }

    function test_settle_allowsPartialAmount() public {
        uint256 t = block.timestamp;
        uint256 permitted = 100e6;
        uint256 requested = 50e6;

        proxy.settle(_permit(permitted, 0, t + 3600), requested, payer, _witness(recipient, t - 60), _sig());

        assertEq(token.balanceOf(recipient), requested);
    }

    function test_settle_atExactValidAfter() public {
        uint256 t = block.timestamp;
        proxy.settle(_permit(TRANSFER_AMOUNT, 0, t + 3600), TRANSFER_AMOUNT, payer, _witness(recipient, t), _sig());
        assertEq(token.balanceOf(recipient), TRANSFER_AMOUNT);
    }

    // --- Security: Reentrancy ---

    function test_settle_blocksReentrancy() public {
        MaliciousReentrantUpto maliciousPermit2 = new MaliciousReentrantUpto();
        vm.startBroadcast();
        x402UptoPermit2Proxy vulnerableProxy = new x402UptoPermit2Proxy();
        vulnerableProxy.initialize(address(maliciousPermit2));
        vm.stopBroadcast();
        maliciousPermit2.setTarget(address(vulnerableProxy));

        MockERC20 testToken = new MockERC20("Test", "TST", 6);
        testToken.mint(payer, MINT_AMOUNT);
        vm.prank(payer);
        testToken.approve(address(maliciousPermit2), type(uint256).max);

        uint256 t = block.timestamp;
        ISignatureTransfer.PermitTransferFrom memory permit = ISignatureTransfer.PermitTransferFrom({
            permitted: ISignatureTransfer.TokenPermissions({token: address(testToken), amount: TRANSFER_AMOUNT}),
            nonce: 0,
            deadline: t + 3600
        });
        x402UptoPermit2Proxy.Witness memory witness = _witness(recipient, t - 60);

        maliciousPermit2.setAttemptReentry(true);
        maliciousPermit2.setAttackParams(permit, TRANSFER_AMOUNT, payer, witness, _sig());

        vm.expectRevert();
        vulnerableProxy.settle(permit, TRANSFER_AMOUNT, payer, witness, _sig());
    }

    // --- Security: Proxy never holds funds ---

    function test_settle_proxyNeverHoldsTokens() public {
        uint256 t = block.timestamp;
        proxy.settle(_permit(TRANSFER_AMOUNT, 0, t + 3600), TRANSFER_AMOUNT, payer, _witness(recipient, t - 60), _sig());
        assertEq(token.balanceOf(address(proxy)), 0);
    }

    // --- settleWithPermit() ---

    function test_settleWithPermit_transfersTokens() public {
        MockERC20Permit permitToken = new MockERC20Permit("USDC", "USDC", 6);
        permitToken.mint(payer, MINT_AMOUNT);
        vm.prank(payer);
        permitToken.approve(address(mockPermit2), type(uint256).max);

        uint256 t = block.timestamp;
        ISignatureTransfer.PermitTransferFrom memory permit = ISignatureTransfer.PermitTransferFrom({
            permitted: ISignatureTransfer.TokenPermissions({token: address(permitToken), amount: TRANSFER_AMOUNT}),
            nonce: 0,
            deadline: t + 3600
        });

        x402BasePermit2Proxy.EIP2612Permit memory permit2612 = x402BasePermit2Proxy.EIP2612Permit({
            value: TRANSFER_AMOUNT,
            deadline: t + 3600,
            v: 27,
            r: bytes32(uint256(1)),
            s: bytes32(uint256(2))
        });

        vm.expectEmit(false, false, false, false);
        emit SettledWithPermit();

        proxy.settleWithPermit(permit2612, permit, TRANSFER_AMOUNT, payer, _witness(recipient, t - 60), _sig());

        assertEq(permitToken.balanceOf(recipient), TRANSFER_AMOUNT);
    }

    function test_settleWithPermit_succeedsWhenPermitFails() public {
        MockERC20Permit permitToken = new MockERC20Permit("USDC", "USDC", 6);
        permitToken.mint(payer, MINT_AMOUNT);
        permitToken.setPermitRevert(true, "Permit failed");

        vm.prank(payer);
        permitToken.approve(address(mockPermit2), type(uint256).max);

        uint256 t = block.timestamp;
        ISignatureTransfer.PermitTransferFrom memory permit = ISignatureTransfer.PermitTransferFrom({
            permitted: ISignatureTransfer.TokenPermissions({token: address(permitToken), amount: TRANSFER_AMOUNT}),
            nonce: 0,
            deadline: t + 3600
        });

        x402BasePermit2Proxy.EIP2612Permit memory permit2612 = x402BasePermit2Proxy.EIP2612Permit({
            value: TRANSFER_AMOUNT,
            deadline: t + 3600,
            v: 27,
            r: bytes32(uint256(1)),
            s: bytes32(uint256(2))
        });

        proxy.settleWithPermit(permit2612, permit, TRANSFER_AMOUNT, payer, _witness(recipient, t - 60), _sig());

        assertEq(permitToken.balanceOf(recipient), TRANSFER_AMOUNT);
    }

    function test_settleWithPermit_emitsEIP2612PermitFailedOnRevert() public {
        MockERC20Permit permitToken = new MockERC20Permit("USDC", "USDC", 6);
        permitToken.mint(payer, MINT_AMOUNT);
        permitToken.setPermitRevert(true, "Permit failed");

        vm.prank(payer);
        permitToken.approve(address(mockPermit2), type(uint256).max);

        uint256 t = block.timestamp;
        ISignatureTransfer.PermitTransferFrom memory permit = ISignatureTransfer.PermitTransferFrom({
            permitted: ISignatureTransfer.TokenPermissions({token: address(permitToken), amount: TRANSFER_AMOUNT}),
            nonce: 0,
            deadline: t + 3600
        });

        x402BasePermit2Proxy.EIP2612Permit memory permit2612 = x402BasePermit2Proxy.EIP2612Permit({
            value: TRANSFER_AMOUNT,
            deadline: t + 3600,
            v: 27,
            r: bytes32(uint256(1)),
            s: bytes32(uint256(2))
        });

        vm.expectEmit(true, true, false, false);
        emit EIP2612PermitFailed(address(permitToken), payer, "");

        proxy.settleWithPermit(permit2612, permit, TRANSFER_AMOUNT, payer, _witness(recipient, t - 60), _sig());
    }

    function test_settleWithPermit_doesNotEmitEIP2612PermitFailedOnSuccess() public {
        MockERC20Permit permitToken = new MockERC20Permit("USDC", "USDC", 6);
        permitToken.mint(payer, MINT_AMOUNT);
        vm.prank(payer);
        permitToken.approve(address(mockPermit2), type(uint256).max);

        uint256 t = block.timestamp;
        ISignatureTransfer.PermitTransferFrom memory permit = ISignatureTransfer.PermitTransferFrom({
            permitted: ISignatureTransfer.TokenPermissions({token: address(permitToken), amount: TRANSFER_AMOUNT}),
            nonce: 0,
            deadline: t + 3600
        });

        x402BasePermit2Proxy.EIP2612Permit memory permit2612 = x402BasePermit2Proxy.EIP2612Permit({
            value: TRANSFER_AMOUNT,
            deadline: t + 3600,
            v: 27,
            r: bytes32(uint256(1)),
            s: bytes32(uint256(2))
        });

        vm.recordLogs();
        proxy.settleWithPermit(permit2612, permit, TRANSFER_AMOUNT, payer, _witness(recipient, t - 60), _sig());

        VmSafe.Log[] memory entries = vm.getRecordedLogs();
        bytes32 permitFailedSig = keccak256("EIP2612PermitFailed(address,address,bytes)");
        for (uint256 i = 0; i < entries.length; i++) {
            assertTrue(entries[i].topics[0] != permitFailedSig, "EIP2612PermitFailed should not be emitted on success");
        }
    }

    function test_settleWithPermit_revertsOnZeroAmount() public {
        MockERC20Permit permitToken = new MockERC20Permit("USDC", "USDC", 6);
        permitToken.mint(payer, MINT_AMOUNT);
        vm.prank(payer);
        permitToken.approve(address(mockPermit2), type(uint256).max);

        uint256 t = block.timestamp;
        ISignatureTransfer.PermitTransferFrom memory permit = ISignatureTransfer.PermitTransferFrom({
            permitted: ISignatureTransfer.TokenPermissions({token: address(permitToken), amount: TRANSFER_AMOUNT}),
            nonce: 0,
            deadline: t + 3600
        });

        x402BasePermit2Proxy.EIP2612Permit memory permit2612 = x402BasePermit2Proxy.EIP2612Permit({
            value: TRANSFER_AMOUNT,
            deadline: t + 3600,
            v: 27,
            r: bytes32(uint256(1)),
            s: bytes32(uint256(2))
        });

        vm.expectRevert(x402BasePermit2Proxy.InvalidAmount.selector);
        proxy.settleWithPermit(permit2612, permit, 0, payer, _witness(recipient, t - 60), _sig());
    }

    function test_settleWithPermit_revertsWhenAmountExceedsPermitted() public {
        MockERC20Permit permitToken = new MockERC20Permit("USDC", "USDC", 6);
        permitToken.mint(payer, MINT_AMOUNT);

        uint256 t = block.timestamp;
        ISignatureTransfer.PermitTransferFrom memory permit = ISignatureTransfer.PermitTransferFrom({
            permitted: ISignatureTransfer.TokenPermissions({token: address(permitToken), amount: 100e6}),
            nonce: 0,
            deadline: t + 3600
        });

        x402BasePermit2Proxy.EIP2612Permit memory permit2612 = x402BasePermit2Proxy.EIP2612Permit({
            value: 100e6,
            deadline: t + 3600,
            v: 27,
            r: bytes32(uint256(1)),
            s: bytes32(uint256(2))
        });

        vm.expectRevert(x402UptoPermit2Proxy.AmountExceedsPermitted.selector);
        proxy.settleWithPermit(permit2612, permit, 150e6, payer, _witness(recipient, t - 60), _sig());
    }

    function test_settleWithPermit_revertsWhenPermit2612ValueTooSmall() public {
        MockERC20Permit permitToken = new MockERC20Permit("USDC", "USDC", 6);
        permitToken.mint(payer, MINT_AMOUNT);

        uint256 t = block.timestamp;
        ISignatureTransfer.PermitTransferFrom memory permit = ISignatureTransfer.PermitTransferFrom({
            permitted: ISignatureTransfer.TokenPermissions({token: address(permitToken), amount: TRANSFER_AMOUNT}),
            nonce: 0,
            deadline: t + 3600
        });

        x402BasePermit2Proxy.EIP2612Permit memory permit2612 = x402BasePermit2Proxy.EIP2612Permit({
            value: TRANSFER_AMOUNT - 1,
            deadline: t + 3600,
            v: 27,
            r: bytes32(uint256(1)),
            s: bytes32(uint256(2))
        });

        vm.expectRevert(x402BasePermit2Proxy.Permit2612AmountMismatch.selector);
        proxy.settleWithPermit(permit2612, permit, TRANSFER_AMOUNT, payer, _witness(recipient, t - 60), _sig());
    }

    function test_settleWithPermit_revertsWhenPermit2612ValueTooLarge() public {
        MockERC20Permit permitToken = new MockERC20Permit("USDC", "USDC", 6);
        permitToken.mint(payer, MINT_AMOUNT);

        uint256 t = block.timestamp;
        ISignatureTransfer.PermitTransferFrom memory permit = ISignatureTransfer.PermitTransferFrom({
            permitted: ISignatureTransfer.TokenPermissions({token: address(permitToken), amount: TRANSFER_AMOUNT}),
            nonce: 0,
            deadline: t + 3600
        });

        x402BasePermit2Proxy.EIP2612Permit memory permit2612 = x402BasePermit2Proxy.EIP2612Permit({
            value: TRANSFER_AMOUNT + 1,
            deadline: t + 3600,
            v: 27,
            r: bytes32(uint256(1)),
            s: bytes32(uint256(2))
        });

        vm.expectRevert(x402BasePermit2Proxy.Permit2612AmountMismatch.selector);
        proxy.settleWithPermit(permit2612, permit, TRANSFER_AMOUNT, payer, _witness(recipient, t - 60), _sig());
    }

    function test_settleWithPermit_partialAmountWithMatchingPermit() public {
        MockERC20Permit permitToken = new MockERC20Permit("USDC", "USDC", 6);
        permitToken.mint(payer, MINT_AMOUNT);
        vm.prank(payer);
        permitToken.approve(address(mockPermit2), type(uint256).max);

        uint256 t = block.timestamp;
        uint256 permitted = TRANSFER_AMOUNT; // 100e6
        uint256 requested = TRANSFER_AMOUNT / 2; // 50e6

        ISignatureTransfer.PermitTransferFrom memory permit = ISignatureTransfer.PermitTransferFrom({
            permitted: ISignatureTransfer.TokenPermissions({token: address(permitToken), amount: permitted}),
            nonce: 0,
            deadline: t + 3600
        });

        x402BasePermit2Proxy.EIP2612Permit memory permit2612 = x402BasePermit2Proxy.EIP2612Permit({
            value: permitted,
            deadline: t + 3600,
            v: 27,
            r: bytes32(uint256(1)),
            s: bytes32(uint256(2))
        });

        proxy.settleWithPermit(permit2612, permit, requested, payer, _witness(recipient, t - 60), _sig());

        assertEq(permitToken.balanceOf(recipient), requested);
    }

    // --- Fuzz: Time window ---

    function testFuzz_settle_afterValidAfter(uint256 validAfter, uint256 currentTime) public {
        validAfter = bound(validAfter, 0, type(uint64).max - 3601);
        currentTime = bound(currentTime, validAfter, type(uint64).max - 3601);

        vm.warp(currentTime);

        proxy.settle(
            _permit(TRANSFER_AMOUNT, 0, currentTime + 3600),
            TRANSFER_AMOUNT,
            payer,
            _witness(recipient, validAfter),
            _sig()
        );

        assertEq(token.balanceOf(recipient), TRANSFER_AMOUNT);
    }

    function testFuzz_settle_revertsBeforeValidAfter(uint256 validAfter, uint256 currentTime) public {
        validAfter = bound(validAfter, 1000, type(uint64).max - 1000);
        currentTime = bound(currentTime, 0, validAfter - 1);

        vm.warp(currentTime);

        vm.expectRevert();
        proxy.settle(
            _permit(TRANSFER_AMOUNT, 0, currentTime + 3600),
            TRANSFER_AMOUNT,
            payer,
            _witness(recipient, validAfter),
            _sig()
        );
    }

    // --- Fuzz: Amount ---

    function testFuzz_settle_amountNeverExceedsPermitted(uint256 permitted, uint256 requested) public {
        permitted = bound(permitted, 1, type(uint128).max);
        requested = bound(requested, permitted + 1, type(uint256).max);

        uint256 t = block.timestamp;

        vm.expectRevert(x402UptoPermit2Proxy.AmountExceedsPermitted.selector);
        proxy.settle(_permit(permitted, 0, t + 3600), requested, payer, _witness(recipient, t - 60), _sig());
    }

    function testFuzz_settle_partialAmountsSucceed(uint256 permitted, uint256 requested) public {
        permitted = bound(permitted, 1, MINT_AMOUNT);
        requested = bound(requested, 1, permitted);

        uint256 t = block.timestamp;

        proxy.settle(_permit(permitted, 0, t + 3600), requested, payer, _witness(recipient, t - 60), _sig());

        assertEq(token.balanceOf(recipient), requested);
    }
}
