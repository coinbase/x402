import { describe, it, expect, beforeEach } from "vitest";
import { Wallet, dropsToXrp, xrpToDrops, isValidAddress } from "xrpl";
import {
  toClientXrpSigner,
  FacilitatorXrpClient,
} from "../../src/signer";
import { isXrpPayload } from "../../src/types";
import { ExactXrpPayloadV2 } from "../../src/types";

describe("signer utilities", () => {
  describe("isXrpPayload", () => {
    it("should return true for valid XRP payload", () => {
      const validPayload: ExactXrpPayloadV2 = {
        signedTransaction: "1200002280000000...",
        transaction: {
          TransactionType: "Payment",
          Account: "rN7n7otQDd6FczFgLdlqtyMVrn3HMfHgFj",
          Destination: "rHb9CJAWyB4rj91VRWn96DkukG4bwdtyTh",
          Amount: "10000",
          Fee: "12",
          Sequence: 1,
          LastLedgerSequence: 1000,
        },
      };
      expect(isXrpPayload(validPayload)).toBe(true);
    });

    it("should return false for non-XRP payload", () => {
      const invalidPayload = {
        signature: "0x1234...",
        authorization: {},
      };
      expect(isXrpPayload(invalidPayload)).toBe(false);
    });

    it("should return false for null/undefined", () => {
      expect(isXrpPayload(null)).toBe(false);
      expect(isXrpPayload(undefined)).toBe(false);
    });
  });

  describe("isValidAddress (from xrpl)", () => {
    it("should validate classic XRP addresses", () => {
      // Generate valid addresses using xrpl Wallet
      const wallet1 = Wallet.generate();
      const wallet2 = Wallet.generate();
      expect(isValidAddress(wallet1.address)).toBe(true);
      expect(isValidAddress(wallet2.address)).toBe(true);
    });

    it("should validate X-addresses", () => {
      // Valid X-address format contains both address and destination tag
      // X-address: X + 1 (testnet/mainnet) + classic address hash + 4-byte tag
      // Using a known valid X-address format
      const xAddress = "X7m1kaW4K3RWMnSWEtTH4gyAYYqR9hT8hC";
      // Note: xrpl's isValidAddress validates the format but this may be network-specific
      // We just verify it doesn't crash and returns a boolean
      const result = isValidAddress(xAddress);
      expect(typeof result).toBe("boolean");
    });

    it("should reject invalid addresses", () => {
      expect(isValidAddress("invalid")).toBe(false);
      expect(isValidAddress("")).toBe(false);
      expect(isValidAddress("rShort")).toBe(false);
      expect(isValidAddress("notanaddress")).toBe(false);
    });
  });

  describe("dropsToXrp / xrpToDrops (from xrpl)", () => {
    it("should convert drops to XRP correctly", () => {
      // dropsToXrp returns a number, not a string
      expect(dropsToXrp("1000000")).toBe(1);
      expect(dropsToXrp("10000")).toBe(0.01);
      expect(dropsToXrp("12")).toBe(0.000012);
    });

    it("should convert XRP to drops correctly", () => {
      expect(xrpToDrops("1")).toBe("1000000");
      expect(xrpToDrops("0.01")).toBe("10000");
      expect(xrpToDrops("0.000012")).toBe("12");
    });

    it("should handle large numbers", () => {
      expect(xrpToDrops("1000000")).toBe("1000000000000");
    });
  });
});

describe("ClientXrpSigner", () => {
  let mockWallet: Wallet;
  let signer: ReturnType<typeof toClientXrpSigner>;

  beforeEach(() => {
    mockWallet = Wallet.generate();
    signer = toClientXrpSigner(mockWallet);
  });

  it("should return the signer's address", () => {
    expect(signer.address).toBe(mockWallet.address);
  });

  it("should sign a payment transaction", async () => {
    // Use a valid XRP address generated by xrpl
    const validDestination = Wallet.generate().address;
    
    const tx = {
      TransactionType: "Payment" as const,
      Account: mockWallet.address,
      Destination: validDestination,
      Amount: "10000",
      Fee: "12",
      Sequence: 1,
      LastLedgerSequence: 1000,
    };

    const result = await signer.signPayment(tx);
    expect(typeof result).toBe("string");
    expect(result.length).toBeGreaterThan(0);
  });

  it("should include memos when signing", async () => {
    const validDestination = Wallet.generate().address;
    
    const tx = {
      TransactionType: "Payment" as const,
      Account: mockWallet.address,
      Destination: validDestination,
      Amount: "10000",
      Fee: "12",
      Sequence: 1,
      LastLedgerSequence: 1000,
      Memos: [
        {
          Memo: {
            MemoType: "7874025F7061796D656E74", // hex for "x402_payment"
            MemoData: "74657374", // hex for "test"
          },
        },
      ],
    };

    const result = await signer.signPayment(tx);
    expect(typeof result).toBe("string");
    expect(result.length).toBeGreaterThan(0);
  });

  it("should include destination tag when signing", async () => {
    const validDestination = Wallet.generate().address;
    
    const tx = {
      TransactionType: "Payment" as const,
      Account: mockWallet.address,
      Destination: validDestination,
      Amount: "10000",
      Fee: "12",
      Sequence: 1,
      LastLedgerSequence: 1000,
      DestinationTag: 12345,
    };

    const result = await signer.signPayment(tx);
    expect(typeof result).toBe("string");
    expect(result.length).toBeGreaterThan(0);
  });

  it("should get next sequence from client", async () => {
    const mockClient = {
      request: vi.fn().mockResolvedValue({
        result: {
          account_data: {
            Sequence: 42,
          },
        },
      }),
    };

    const sequence = await signer.getNextSequence(mockClient as any);
    expect(sequence).toBe(42);
  });

  it("should return sequence 1 for new account", async () => {
    const mockClient = {
      request: vi.fn().mockRejectedValue(new Error("actNotFound")),
    };

    const sequence = await signer.getNextSequence(mockClient as any);
    expect(sequence).toBe(1);
  });
});

describe("FacilitatorXrpClient", () => {
  it("should create facilitator client with config", () => {
    const client = new FacilitatorXrpClient({
      server: "wss://testnet.xrpl-labs.com",
      maxRetries: 3,
      retryDelayMs: 1000,
      validationTimeoutMs: 60000,
    });
    expect(client).toBeDefined();
    expect(client.getAddresses()).toEqual([]);
  });

  it("should add addresses to facilitator client", () => {
    const client = new FacilitatorXrpClient({
      server: "wss://testnet.xrpl-labs.com",
    });
    
    client.addAddress("rN7n7otQDd6FczFgLdlqtyMVrn3HMfHgFj");
    expect(client.getAddresses()).toContain("rN7n7otQDd6FczFgLdlqtyMVrn3HMfHgFj");
  });

  it("should not add duplicate addresses", () => {
    const client = new FacilitatorXrpClient({
      server: "wss://testnet.xrpl-labs.com",
    });
    
    client.addAddress("rN7n7otQDd6FczFgLdlqtyMVrn3HMfHgFj");
    client.addAddress("rN7n7otQDd6FczFgLdlqtyMVrn3HMfHgFj");
    expect(client.getAddresses().length).toBe(1);
  });

  it("should return readonly addresses array", () => {
    const client = new FacilitatorXrpClient({
      server: "wss://testnet.xrpl-labs.com",
    });
    
    client.addAddress("rAddress1");
    const addresses = client.getAddresses();
    
    // Should be a copy, not the original
    expect(() => {
      (addresses as string[]).push("rAddress2");
    }).not.toThrow();
    
    // Original should be unchanged
    expect(client.getAddresses()).toEqual(["rAddress1"]);
  });
});

import { vi } from "vitest";
